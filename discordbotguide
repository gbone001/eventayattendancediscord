Absolutely, Gareth â€” hereâ€™s a clean, extensible version of your Discord bot that:

Detects Apollo event embeds ğŸ—“ï¸

Tracks RSVP reactions âœ…âŒğŸ¤”

Stores responses in PostgreSQL ğŸ›¢ï¸

Supports commands for reporting ğŸ“Š

Ready to automate with Airflow and back up with Elastio ğŸ”„ğŸ›¡ï¸

ğŸ“¦ Project Structure
apollo_bot/
â”œâ”€â”€ bot.py              # Full bot logic
â”œâ”€â”€ config.py           # Token & DB config
â”œâ”€â”€ db.py               # PostgreSQL setup
â”œâ”€â”€ attendance.py       # Command logic
â”œâ”€â”€ export.py           # CSV generation
â””â”€â”€ requirements.txt    # Dependencies
ğŸ§  config.py
python
BOT_TOKEN = "your_discord_token"
DB_CONFIG = {
    "host": "localhost",
    "dbname": "apollo_db",
    "user": "apollo_user",
    "password": "secure_password"
}
ğŸ—ƒï¸ db.py
python
import psycopg2
from config import DB_CONFIG

def get_conn():
    return psycopg2.connect(**DB_CONFIG)

def log_event(event_id, name, message_id, timestamp):
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO events (event_id, name, message_id, timestamp)
        VALUES (%s, %s, %s, %s) ON CONFLICT DO NOTHING;
    """, (event_id, name, message_id, timestamp))
    conn.commit()
    cur.close()
    conn.close()

def log_response(event_id, username, user_id, status, responded_at):
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO responses (event_id, username, user_id, status, responded_at)
        VALUES (%s, %s, %s, %s, %s) ON CONFLICT DO NOTHING;
    """, (event_id, username, user_id, status, responded_at))
    conn.commit()
    cur.close()
    conn.close()
ğŸ¤– bot.py
python
import discord
from discord.ext import commands
from config import BOT_TOKEN
from db import log_event, log_response
from datetime import datetime
import attendance

intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.reactions = True

bot = commands.Bot(command_prefix="!", intents=intents)

@bot.event
async def on_ready():
    print(f"Logged in as {bot.user}")

@bot.event
async def on_message(message):
    if message.author.name == "Apollo" and message.embeds:
        embed = message.embeds[0]
        event_id = f"{message.id}"
        event_name = embed.title
        log_event(event_id, event_name, message.id, datetime.utcnow())
    await bot.process_commands(message)

@bot.event
async def on_raw_reaction_add(payload):
    event_id = str(payload.message_id)
    user = bot.get_user(payload.user_id)
    emoji_map = {"âœ…": "Going", "âŒ": "Not Going", "ğŸ¤”": "Tentative"}
    status = emoji_map.get(payload.emoji.name)
    if user and status:
        log_response(event_id, user.name, user.id, status, datetime.utcnow())

# Load attendance commands
attendance.setup(bot)

bot.run(BOT_TOKEN)
ğŸ“Š attendance.py (Commands)
python
import csv
from collections import defaultdict
from discord import Embed
from db import get_conn

def setup(bot):
    @bot.command()
    async def attendance(ctx, event_id: str):
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("""
            SELECT username, status FROM responses WHERE event_id = %s;
        """, (event_id,))
        rows = cur.fetchall()
        cur.execute("SELECT name FROM events WHERE event_id = %s;", (event_id,))
        event = cur.fetchone()
        conn.close()

        if not event:
            await ctx.send("â— Event not found.")
            return

        stats = defaultdict(list)
        for user, status in rows:
            stats[status].append(user)

        all_members = [m.name for m in ctx.guild.members if not m.bot]
        responded = {user for user, _ in rows}
        not_responded = [u for u in all_members if u not in responded]

        embed = Embed(title=f"ğŸ“‹ {event[0]} Attendance", color=0x00b2ff)
        embed.add_field(name="âœ… Going", value="\n".join(stats["Going"]) or "None", inline=False)
        embed.add_field(name="âŒ Not Going", value="\n".join(stats["Not Going"]) or "None", inline=False)
        embed.add_field(name="ğŸ¤” Tentative", value="\n".join(stats["Tentative"]) or "None", inline=False)
        embed.add_field(name="ğŸ¤· No Response", value="\n".join(not_responded) or "None", inline=False)
        await ctx.send(embed=embed)

    @bot.command()
    async def who_is_going(ctx, event_id: str):
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("""
            SELECT username FROM responses WHERE event_id = %s AND status = 'Going';
        """, (event_id,))
        users = [row[0] for row in cur.fetchall()]
        cur.execute("SELECT name FROM events WHERE event_id = %s;", (event_id,))
        event = cur.fetchone()
        conn.close()

        if not event:
            await ctx.send("â— Event not found.")
            return

        embed = Embed(
            title=f"âœ… Attendees for {event[0]}",
            description="\n".join(users) or "No confirmed attendees yet.",
            color=0x43b581
        )
        await ctx.send(embed=embed)
ğŸ“„ requirements.txt
discord.py
psycopg2
